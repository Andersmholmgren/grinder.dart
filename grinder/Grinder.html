        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Grinder class / grinder Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="grinder" data-type="Grinder">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../grinder.html">grinder</a> &rsaquo; <a href="../grinder/Grinder.html">Grinder</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Grinder</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>A class representing a running instance of a Grinder.</p>
<pre class="source">
class Grinder {
 List&lt;GrinderTask&gt; _tasks = [];
 Map&lt;GrinderTask, List&gt; _taskDeps;
 List&lt;GrinderTask&gt; _calcedTasks = [];

 /// Create a new instance of Grinder.
 Grinder();

 /// Add a task to this Grinder instance.
 void addTask(GrinderTask task) =&gt; _tasks.add(task);

 /// Get the list of all the Grinder tasks.
 List&lt;GrinderTask&gt; get tasks =&gt; _tasks;

 /// Get the task with the given name. Returns `null` if none found.
 GrinderTask getTask(String name) =&gt;
     _tasks.firstWhere((t) =&gt; t.name == name, orElse: () =&gt; null);

 /// Return the calculated build order of the tasks for this run.
 List&lt;GrinderTask&gt; getBuildOrder() {
   return _calcedTasks;
 }

 /**
  * Start the build process and run all the tasks in the calculated build
  * order.
  *
  * [start] should be called once and only once; i.e., Grinder instances are
  * not re-usable.
  *
  * The [dontRun] parameter can be used to audit the grinder file, without
  * actually executing any targets.
  *
  * Throws [GrinderException] if named tasks don't exist, or there are
  * cycles in the dependency graph.
  */
 void start(List&lt;String&gt; targets, {bool dontRun: false}) {
   if (_taskDeps != null) {
     throw new StateError("Grinder instances are not re-usable");
   }

   DateTime startTime = new DateTime.now();

   // verify that all named tasks exist
   for (String taskName in targets) {
     if (getTask(taskName) == null) {
       throw new GrinderException("task '${taskName}' doesn't exist");
     }
   }

   List&lt;GrinderTask&gt; tasksToRun = targets.map(
       (name) =&gt; getTask(name)).toList();

   // verify that all referenced tasks exist
   for (GrinderTask task in tasks) {
     for (String name in task.depends) {
       if (getTask(name) == null) {
         throw new GrinderException(
             "task '${name}' referenced by ${task}, doesn't exist");
       }
     }
   }

   _calculateAllDeps();

   // verify that there are no dependency cycles
   for (GrinderTask task in tasks) {
     if (getAllDependencies(task).contains(task)) {
       throw new GrinderException("Task ${task} has a dependency cycle.\n"
           "  ${task} ==&gt; ${getAllDependencies(task).join(', ')}");
     }
   }

   // print out the calculated tasks + order
   for (GrinderTask task in tasksToRun) {
     if (!_calcedTasks.contains(task)) {
       _calcedTasks.add(task);

       for (GrinderTask depTask in getAllDependencies(task)) {
         if (!_calcedTasks.contains(depTask)) {
           _calcedTasks.add(depTask);
         }
       }
     }
   }

   _sortTasks(_calcedTasks);

   if (!dontRun) {
     log('grinder running ${_calcedTasks.join(', ')}');
     log('');

     for (GrinderTask task in _calcedTasks) {
       _executeTask(task);
     }

     Duration elapsed = new DateTime.now().difference(startTime);
     log('finished in ${elapsed.inMilliseconds / 1000.0} seconds.');
   }
 }

 /// Given a task, return all of its immediate dependencies.
 Iterable&lt;GrinderTask&gt; getImmediateDependencies(GrinderTask task) {
   return task.depends.map((name) =&gt; getTask(name));
 }

 /// Given a task, return all of its transitive dependencies.
 List&lt;GrinderTask&gt; getAllDependencies(GrinderTask task) =&gt; _taskDeps[task];

 /// Log the given informational message.
 void log(String message) =&gt; print(message);

 void _executeTask(GrinderTask task) {
   log('${task}');

   GrinderContext context = new GrinderContext._(this, task);
   task.execute(context);

   log('');
 }

 void _calculateAllDeps() {
   _taskDeps = new Map();

   for (GrinderTask task in _tasks) {
     _taskDeps[task] = _calcDependencies(task, new Set()).toList();
   }

   // sort the deps
   for (List&lt;GrinderTask&gt; deps in _taskDeps.values) {
     _sortTasks(deps);
   }
 }

 Set&lt;GrinderTask&gt; _calcDependencies(GrinderTask task, Set&lt;GrinderTask&gt; foundTasks) {
   for (GrinderTask childTask in getImmediateDependencies(task)) {
     bool contains = foundTasks.contains(childTask);
     foundTasks.add(childTask);
     if (!contains) {
       _calcDependencies(childTask, foundTasks);
     }
   }
   return foundTasks;
 }

 void _sortTasks(List&lt;GrinderTask&gt; tasks) {
   tasks.sort((t1, t2) {
     if (getAllDependencies(t2).contains(t1)) {
       return -1;
     } else if (getAllDependencies(t1).contains(t2)) {
       return 1;
     } else {
       // Use the task name to break ties. This means that we will have
       // consistent execution order regardless of the order the tasks are
       // specified on the command-line.
       return t1.name.compareTo(t2.name);
     }
   });
 }
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>Grinder</strong>() <a class="anchor-link" href="#"
              title="Permalink to Grinder.Grinder">#</a></h4>
<div class="doc">
<p>Create a new instance of Grinder.</p>
<pre class="source">
Grinder();
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="tasks">
<button class="show-code">Code</button>
final List&lt;<a href="../grinder/GrinderTask.html">GrinderTask</a>&gt;         <strong>tasks</strong> <a class="anchor-link"
            href="#tasks"
            title="Permalink to Grinder.tasks">#</a>
        </h4>
        <div class="doc">
<p>Get the list of all the Grinder tasks.</p>
<pre class="source">
List&lt;GrinderTask&gt; get tasks =&gt; _tasks;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="addTask">
<button class="show-code">Code</button>
void <strong>addTask</strong>(<a href="../grinder/GrinderTask.html">GrinderTask</a> task) <a class="anchor-link" href="#addTask"
              title="Permalink to Grinder.addTask">#</a></h4>
<div class="doc">
<p>Add a task to this Grinder instance.</p>
<pre class="source">
void addTask(GrinderTask task) =&gt; _tasks.add(task);
</pre>
</div>
</div>
<div class="method"><h4 id="getAllDependencies">
<button class="show-code">Code</button>
List&lt;<a href="../grinder/GrinderTask.html">GrinderTask</a>&gt; <strong>getAllDependencies</strong>(<a href="../grinder/GrinderTask.html">GrinderTask</a> task) <a class="anchor-link" href="#getAllDependencies"
              title="Permalink to Grinder.getAllDependencies">#</a></h4>
<div class="doc">
<p>Given a task, return all of its transitive dependencies.</p>
<pre class="source">
List&lt;GrinderTask&gt; getAllDependencies(GrinderTask task) =&gt; _taskDeps[task];
</pre>
</div>
</div>
<div class="method"><h4 id="getBuildOrder">
<button class="show-code">Code</button>
List&lt;<a href="../grinder/GrinderTask.html">GrinderTask</a>&gt; <strong>getBuildOrder</strong>() <a class="anchor-link" href="#getBuildOrder"
              title="Permalink to Grinder.getBuildOrder">#</a></h4>
<div class="doc">
<p>Return the calculated build order of the tasks for this run.</p>
<pre class="source">
List&lt;GrinderTask&gt; getBuildOrder() {
 return _calcedTasks;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getImmediateDependencies">
<button class="show-code">Code</button>
Iterable&lt;<a href="../grinder/GrinderTask.html">GrinderTask</a>&gt; <strong>getImmediateDependencies</strong>(<a href="../grinder/GrinderTask.html">GrinderTask</a> task) <a class="anchor-link" href="#getImmediateDependencies"
              title="Permalink to Grinder.getImmediateDependencies">#</a></h4>
<div class="doc">
<p>Given a task, return all of its immediate dependencies.</p>
<pre class="source">
Iterable&lt;GrinderTask&gt; getImmediateDependencies(GrinderTask task) {
 return task.depends.map((name) =&gt; getTask(name));
}
</pre>
</div>
</div>
<div class="method"><h4 id="getTask">
<button class="show-code">Code</button>
<a href="../grinder/GrinderTask.html">GrinderTask</a> <strong>getTask</strong>(String name) <a class="anchor-link" href="#getTask"
              title="Permalink to Grinder.getTask">#</a></h4>
<div class="doc">
<p>Get the task with the given name. Returns <code>null</code> if none found.</p>
<pre class="source">
GrinderTask getTask(String name) =&gt;
   _tasks.firstWhere((t) =&gt; t.name == name, orElse: () =&gt; null);
</pre>
</div>
</div>
<div class="method"><h4 id="log">
<button class="show-code">Code</button>
void <strong>log</strong>(String message) <a class="anchor-link" href="#log"
              title="Permalink to Grinder.log">#</a></h4>
<div class="doc">
<p>Log the given informational message.</p>
<pre class="source">
void log(String message) =&gt; print(message);
</pre>
</div>
</div>
<div class="method"><h4 id="start">
<button class="show-code">Code</button>
void <strong>start</strong>(List&lt;String&gt; targets, {bool dontRun: false}) <a class="anchor-link" href="#start"
              title="Permalink to Grinder.start">#</a></h4>
<div class="doc">
<p>Start the build process and run all the tasks in the calculated build
order.</p>
<p><a class="crossref" href="../grinder/Grinder.html#start">start</a> should be called once and only once; i.e., Grinder instances are
not re-usable.</p>
<p>The 
<span class="param">dontRun</span> parameter can be used to audit the grinder file, without
actually executing any targets.</p>
<p>Throws <a class="crossref" href="../grinder/GrinderException.html">GrinderException</a> if named tasks don't exist, or there are
cycles in the dependency graph.</p>
<pre class="source">
void start(List&lt;String&gt; targets, {bool dontRun: false}) {
 if (_taskDeps != null) {
   throw new StateError("Grinder instances are not re-usable");
 }

 DateTime startTime = new DateTime.now();

 // verify that all named tasks exist
 for (String taskName in targets) {
   if (getTask(taskName) == null) {
     throw new GrinderException("task '${taskName}' doesn't exist");
   }
 }

 List&lt;GrinderTask&gt; tasksToRun = targets.map(
     (name) =&gt; getTask(name)).toList();

 // verify that all referenced tasks exist
 for (GrinderTask task in tasks) {
   for (String name in task.depends) {
     if (getTask(name) == null) {
       throw new GrinderException(
           "task '${name}' referenced by ${task}, doesn't exist");
     }
   }
 }

 _calculateAllDeps();

 // verify that there are no dependency cycles
 for (GrinderTask task in tasks) {
   if (getAllDependencies(task).contains(task)) {
     throw new GrinderException("Task ${task} has a dependency cycle.\n"
         "  ${task} ==&gt; ${getAllDependencies(task).join(', ')}");
   }
 }

 // print out the calculated tasks + order
 for (GrinderTask task in tasksToRun) {
   if (!_calcedTasks.contains(task)) {
     _calcedTasks.add(task);

     for (GrinderTask depTask in getAllDependencies(task)) {
       if (!_calcedTasks.contains(depTask)) {
         _calcedTasks.add(depTask);
       }
     }
   }
 }

 _sortTasks(_calcedTasks);

 if (!dontRun) {
   log('grinder running ${_calcedTasks.join(', ')}');
   log('');

   for (GrinderTask task in _calcedTasks) {
     _executeTask(task);
   }

   Duration elapsed = new DateTime.now().difference(startTime);
   log('finished in ${elapsed.inMilliseconds / 1000.0} seconds.');
 }
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
